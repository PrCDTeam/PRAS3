package com.pointroll.utils{	import flash.display.MovieClip;	import com.greensock.TweenNano;		import flash.events.Event;	import flash.events.EventDispatcher;		import flash.display.Sprite;		import flash.utils.Timer;	import flash.events.TimerEvent;		import com.pointroll.events.PRScrollerEvents;	public class PRScroller extends Sprite{		private var _xmlData:XML;		private var _totalItems:int;		public var _currentPage:int;		private var _totalPages:int;		private var _howManyToDisplay:int;		private var _maskMc:Sprite;		private var _holder:MovieClip;		private var _itemWidth:Number;		private var _distance:Number;		private var _startX:Number;		private var _canScroll:Boolean;				private var _items:Array;				private var _timer:Timer;				private var _dataObject:Object;		public function PRScroller(h:MovieClip,m:Sprite, numberOfItems:int,howManyProductsToDisplay:int) {			//_items = items;			_holder = h;			_maskMc = m;			_totalItems = numberOfItems;			_howManyToDisplay = howManyProductsToDisplay;			_totalPages = Math.ceil((_totalItems / _howManyToDisplay));			_itemWidth = _holder.width / _totalItems;			_currentPage = 1;			_distance = _itemWidth * _howManyToDisplay;			_canScroll = true;			_dataObject = new Object();			buildScroller();		}		public function autoScroll(d:Number):void{			_timer = new Timer(d);			_timer.addEventListener(TimerEvent.TIMER, onTimerEvent);				_timer.start();		}		public function reset(numberOfItems:int,howManyProductsToDisplay:int):void{			_totalItems = numberOfItems;			_howManyToDisplay = howManyProductsToDisplay;			_totalPages = Math.ceil((_totalItems / _howManyToDisplay));			_itemWidth = _holder.width / _totalItems;			_currentPage = 1;			_distance = _itemWidth * _howManyToDisplay;			_canScroll = true;			_startX = _holder.x			buildScroller();		}		public function moveRight():void {						if (_canScroll) {				if (_currentPage != 1) {					_canScroll = false;					TweenNano.to(_holder,1,{x:(_distance+_holder.x),onComplete:onScrollerTweening});					_currentPage--;					_dataObject.currentPage = _currentPage;					dispatchEvent(new PRScrollerEvents(PRScrollerEvents.ON_SCROLL_RIGHT, _dataObject));					if(_currentPage == 1){						dispatchEvent(new PRScrollerEvents(PRScrollerEvents.ON_SCROLL_RIGHT_END,_dataObject));					}				}								}		}		public function moveLeft():void {				if (_canScroll) {														if (_currentPage != _totalPages) {										_canScroll = false;					TweenNano.to(_holder,1,{x:(_holder.x-_distance),onComplete:onScrollerTweening});					_currentPage++;				 	_dataObject.currentPage = _currentPage;					dispatchEvent(new PRScrollerEvents(PRScrollerEvents.ON_SCROLL_LEFT, _dataObject));				}				if(_currentPage == _totalPages){					if(_timer)						killTimer();											dispatchEvent(new PRScrollerEvents(PRScrollerEvents.ON_SCROLL_LEFT_END,_dataObject));				}			}		}		public function resetToStartPosition():void{			trace("resetToStartPosition()");			TweenNano.to(_holder,.5,{x:_maskMc.x});			_currentPage = 1;		}		public function killTimer():void{			if(_timer){				_timer.stop();				_timer.removeEventListener(TimerEvent.TIMER, onTimerEvent);				_timer = null;			}		}				private function buildScroller():void {			trace("buildScroller ::> _howManyToDisplay: " +_howManyToDisplay + " _totalPages: " + _totalPages + " " + _distance);			_holder.mask = _maskMc;			_holder.x = _maskMc.x;			_holder.y = _maskMc.y;		}				//EVENTS		private function onScrollerTweening():void {			_canScroll = true;		}				private function onTimerEvent(e:TimerEvent):void{			moveLeft();		}						// GETTERS SETTERS		public function get currentPage():Number{			return _currentPage;		}	}}